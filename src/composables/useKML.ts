// Generated by Copilot
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ref, reactive, toRaw } from 'vue';
import type { Map } from 'maplibre-gl';
import { Popup } from 'maplibre-gl';
import toGeoJSON from '../togeojson.js';

// AQI styleUrl -> color mapping (hex), derived from the provided legend
const AQI_STYLE_COLORS: Record<string, string> = {
  '#undefined': '#D9D9D9',
  '#normalstateundefined': '#D9D9D9',
  '#highlightstateundefined': '#D9D9D9',
  '#legendicon': '#D9D9D9',

  '#good': '#00E400',
  '#normalstategood': '#00E400',
  '#highlightstategood': '#00E400',

  '#moderate': '#FFFF00',
  '#normalstatemoderate': '#FFFF00',
  '#highlightstatemoderate': '#FFFF00',

  '#unhealthysg': '#FF7E00',
  '#normalstateunhealthysg': '#FF7E00',
  '#highlightstateunhealthysg': '#FF7E00',

  '#unhealthy': '#FF0000',
  '#normalstateunhealthy': '#FF0000',
  '#highlightstateunhealthy': '#FF0000',

  '#veryunhealthy': '#8F3F97',
  '#normalstateveryunhealthy': '#8F3F97',
  '#highlightstateveryunhealthy': '#8F3F97',

  '#hazardous': '#7E0023',
  '#normalstatehazardous': '#7E0023',
  '#highlightstatehazardous': '#7E0023'
};

// Normalize and resolve a styleUrl to an AQI color
function getAqiColorFromStyleUrl(styleUrlRaw: string | null | undefined): string {
  const key = (styleUrlRaw || '').trim();
  if (!key) return '#D9D9D9';
  // ensure hash prefix and lowercase for lookup
  const normalized = (key.startsWith('#') ? key : `#${key}`).toLowerCase();
  return AQI_STYLE_COLORS[normalized] || '#D9D9D9';
}

export interface KMLLayer {
  addToMap: (map: Map) => Promise<void>
  removeFromMap: (map: Map) => void
  geoJsonData: any
  loading: boolean
  error: string | null
  kmlLayerVisible: boolean
  toggleKmlVisibility: (vis: boolean | undefined) => void
}

// Optional settings for labels
export interface UseKMLOptions {
  propertyToShow?: string | null;   // e.g., 'aqi'. If null/undefined, no labels are shown.
  labelMinZoom?: number;            // min zoom at which labels appear
  layerName?: string;               // custom id base for source/layers, e.g. 'aqi'
}

// Helper to sanitize a user-provided layer name into an id-safe suffix
function sanitizeIdBase(name: string): string {
  return name.trim().toLowerCase().replace(/[^a-z0-9-_]+/g, '-');
}

export function useKML(url: string, options: UseKMLOptions = {}): KMLLayer {
  const geoJsonData = ref<any>(null);
  const loading = ref(false);
  const error = ref<string | null>(null);
  const kmlLayerVisible = ref(true);

  const propertyToShow = options.propertyToShow ?? null;
  const labelMinZoom = options.labelMinZoom ?? 8;

  // Convert KML to GeoJSON
  const convertKmlToGeoJson = (kmlContent: string): any => {
    try {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlContent, 'application/xml');
      
      // Check for parsing errors
      const parseError = kmlDoc.querySelector('parsererror');
      if (parseError) {
        throw new Error('Invalid KML format');
      }
      
      // Convert using local togeojson library
      const geoJson = toGeoJSON.kml(kmlDoc, { styles: true });
      
      // Debug: Log the parsed GeoJSON structure
      console.log('=== KML PARSING DEBUG ===');
      console.log('URL:', url);
      console.log('Total features:', geoJson.features.length);
      console.log('First few features with properties:', geoJson.features.slice(0, 3).map(f => ({
        geometry: f.geometry,
        properties: f.properties
      })));
      
      // Post-process to apply styleHash-based coloring
      const processedGeoJson = postProcessGeoJson(geoJson);
      
      return processedGeoJson;
    } catch (err) {
      console.error('KML conversion error:', err);
      throw new Error(`Failed to convert KML: ${err instanceof Error ? err.message : 'Unknown error'}`);
    }
  };

  // Post-process GeoJSON to apply styleUrl-based AQI coloring
  const postProcessGeoJson = (geoJson: any): any => {
    const processedFeatures = geoJson.features.map((feature: any) => {
      const processedFeature = { ...feature };
      const props = processedFeature.properties || {};
      const styleUrl = props.styleUrl ?? props.styleURL ?? null;
      const color = getAqiColorFromStyleUrl(styleUrl);
      processedFeature.properties = {
        ...props,
        'marker-color': color
      };
      return processedFeature;
    });

    return {
      ...geoJson,
      features: processedFeatures
    };
  };

  // Load KML from URL
  const loadKML = async (): Promise<void> => {
    loading.value = true;
    error.value = null;
    
    try {
      console.log('Loading KML from:', url);
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const kmlContent = await response.text();
      const geoJson = convertKmlToGeoJson(kmlContent);
      
      geoJsonData.value = geoJson;
      console.log('KML loaded successfully:', geoJson.features.length, 'features');
      
    } catch (err) {
      console.error('Error loading KML:', err);
      error.value = err instanceof Error ? err.message : 'Unknown error';
      throw err;
    } finally {
      loading.value = false;
    }
  };

  // Add GeoJSON to map
  const addToMap = async (map: Map): Promise<void> => {
    try {
      // Load KML if not already loaded
      if (!geoJsonData.value) {
        await loadKML();
      }

      if (!geoJsonData.value) {
        throw new Error('No GeoJSON data available');
      }

      console.log('=== ADDING TO MAP DEBUG ===');
      console.log('GeoJSON being added to map:', {
        type: geoJsonData.value.type,
        featureCount: geoJsonData.value.features.length,
        sampleFeature: geoJsonData.value.features[0]
      });
      
      // Prefer stable, human-readable ids when layerName is provided
      const idBase = options.layerName ? sanitizeIdBase(options.layerName) : `${Date.now()}`;
      const sourceId = `kml-source-${idBase}`;
      const layerId = `kml-layer-${idBase}`;
      const labelLayerId = propertyToShow ? `kml-layer-${idBase}-labels` : null;
      
      // Remove existing layer and source if they exist
      if (map.getLayer(layerId)) {
        map.removeLayer(layerId);
      }
      if (labelLayerId && map.getLayer(labelLayerId)) {
        map.removeLayer(labelLayerId);
      }
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId);
      }

      console.log(toRaw(geoJsonData.value));
      // Add new source and layer
      map.addSource(sourceId, {
        type: 'geojson',
        data: geoJsonData.value
      });

      // Add point layer colored by 'marker-color'
      map.addLayer({
        id: layerId,
        type: 'circle',
        source: sourceId,
        paint: {
          'circle-radius': [
            'interpolate', ['linear'], ['zoom'],
            0, 1,
            5, 8,
            20, 12
          ],
          'circle-color': [
            'case',
            ['has', 'marker-color'],
            ['get', 'marker-color'],
            '#808080'
          ],
          'circle-stroke-color': '#444444',
          'circle-stroke-width': 1,
          // opacity
          'circle-opacity': 0.8
        },
        filter: ['==', '$type', 'Point']
      });

      // Conditionally add text labels based on options.propertyToShow
      if (propertyToShow) {
        map.addLayer({
          id: labelLayerId!,
          type: 'symbol',
          source: sourceId,
          minzoom: labelMinZoom,
          layout: {
            'text-field': ['coalesce', ['to-string', ['get', propertyToShow]], ''],
            'text-size': 10,
            'text-offset': [0, 0]
          },
          paint: {
            'text-color': '#1a1a1a',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          },
          filter: ['==', '$type', 'Point']
        });

        // Initial sync and watcher: keep label visibility equal to main layer
        const syncLabelVisibility = () => {
          if (!map.getLayer(layerId) || !map.getLayer(labelLayerId!)) return;
          const mainVis = (map.getLayoutProperty(layerId, 'visibility') as string) || 'visible';
          const labelVis = (map.getLayoutProperty(labelLayerId!, 'visibility') as string) || 'visible';
          if (labelVis !== mainVis) {
            map.setLayoutProperty(labelLayerId!, 'visibility', mainVis);
          }
        };
        // Set initial visibility to match main layer
        syncLabelVisibility();
        // Watch for style/layout changes and resync
        map.on('styledata', syncLabelVisibility);
        // Store handler for cleanup
        (addToMap as any)._onStyleData = syncLabelVisibility;
      }

      // Add hover popup showing only the AQI (or configured property)
      const popup = new Popup({ closeButton: false, closeOnClick: false, maxWidth: '200px' });
      const valueProp = propertyToShow || 'aqi';
      const onEnter = (e: any) => {
        map.getCanvas().style.cursor = 'pointer';
        const f = e.features && e.features[0];
        const val = f?.properties?.[valueProp];
        if (val !== undefined && val !== null && `${val}` !== '') {
          popup
            .setLngLat(e.lngLat)
            .setHTML(`<div style="font:12px sans-serif;color:#000">AQI: ${val}</div>`)
            .addTo(map);
        }
      };
      const onMove = (e: any) => {
        if ((popup as any)._map) {
          popup.setLngLat(e.lngLat);
          const f = e.features && e.features[0];
          const val = f?.properties?.[valueProp];
          if (val !== undefined && val !== null && `${val}` !== '') {
            popup.setHTML(`<div style="font:12px sans-serif;color:#000">AQI: ${val}</div>`);
          }
        }
      };
      const onLeave = () => {
        map.getCanvas().style.cursor = '';
        popup.remove();
      };
      map.on('click', layerId, onEnter);
      map.on('mousemove', layerId, onMove);
      map.on('mouseleave', layerId, onLeave);

      // Store layer info, handlers, and map for toggle
      (addToMap as any)._sourceId = sourceId;
      (addToMap as any)._layerId = layerId;
      (addToMap as any)._labelLayerId = labelLayerId;
      (addToMap as any)._popup = popup;
      (addToMap as any)._onEnter = onEnter;
      (addToMap as any)._onMove = onMove;
      (addToMap as any)._onLeave = onLeave;
      (addToMap as any)._map = map;

      // Apply initial visibility based on kmlLayerVisible
      const initialVis = kmlLayerVisible.value ? 'visible' : 'none';
      map.setLayoutProperty(layerId, 'visibility', initialVis);
      if (labelLayerId && map.getLayer(labelLayerId)) {
        map.setLayoutProperty(labelLayerId, 'visibility', initialVis);
      }

      console.log('Successfully added KML layer to map');
    } catch (err) {
      console.error('Error adding KML to map:', err);
      error.value = err instanceof Error ? err.message : 'Unknown error';
      throw err;
    }
  };

  // Toggle visibility for main and label layers
  const toggleKmlVisibility = (val: boolean | undefined): void => {
    const map: Map | undefined = (addToMap as any)._map;
    const layerId: string | undefined = (addToMap as any)._layerId;
    const labelLayerId: string | undefined = (addToMap as any)._labelLayerId;
    const next = val ?? !kmlLayerVisible.value;
    kmlLayerVisible.value = next;

    if (!map || !layerId) return;
    const vis = next ? 'visible' : 'none';
    if (map.getLayer(layerId)) {
      map.setLayoutProperty(layerId, 'visibility', vis);
    }
    if (labelLayerId && map.getLayer(labelLayerId)) {
      map.setLayoutProperty(labelLayerId, 'visibility', vis);
    }
  };

  // Remove from map
  const removeFromMap = (map: Map): void => {
    try {
      const sourceId = (addToMap as any)._sourceId;
      const layerId = (addToMap as any)._layerId;
      const labelLayerId = (addToMap as any)._labelLayerId;
      const onStyleData = (addToMap as any)._onStyleData;
      const popup: Popup | undefined = (addToMap as any)._popup;
      const onEnter = (addToMap as any)._onEnter;
      const onMove = (addToMap as any)._onMove;
      const onLeave = (addToMap as any)._onLeave;

      // Remove hover handlers and popup
      if (layerId) {
        if (onEnter) map.off('mouseenter', layerId, onEnter);
        if (onMove) map.off('mousemove', layerId, onMove);
        if (onLeave) map.off('mouseleave', layerId, onLeave);
      }
      if (popup) popup.remove();

      // Remove watcher
      if (onStyleData) {
        map.off('styledata', onStyleData);
        (addToMap as any)._onStyleData = undefined;
      }

      // Remove layers and source
      if (labelLayerId && map.getLayer(labelLayerId)) {
        map.removeLayer(labelLayerId);
      }
      if (layerId && map.getLayer(layerId)) {
        map.removeLayer(layerId);
      }
      if (sourceId && map.getSource(sourceId)) {
        map.removeSource(sourceId);
      }

      // Clear stored map
      (addToMap as any)._map = undefined;
      console.log('KML layer removed from map');
    } catch (err) {
      console.error('Error removing KML from map:', err);
    }
  };

  return reactive({
    addToMap,
    removeFromMap,
    geoJsonData,
    loading,
    error,
    kmlLayerVisible,
    toggleKmlVisibility
  });
}