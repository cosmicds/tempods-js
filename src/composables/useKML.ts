// Generated by Copilot
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ref, toRaw, watch, computed, type WritableComputedRef, type Ref } from 'vue';
import M from 'maplibre-gl';
import { Popup } from 'maplibre-gl';
import toGeoJSON from '../togeojson.js';

// AQI styleUrl -> color mapping (hex), derived from the provided legend
const AQI_STYLE_COLORS: Record<string, string> = {
  '#undefined': '#D9D9D9',
  '#normalstateundefined': '#D9D9D9',
  '#highlightstateundefined': '#D9D9D9',
  '#legendicon': '#D9D9D9',

  '#good': '#00E400',
  '#normalstategood': '#00E400',
  '#highlightstategood': '#00E400',

  '#moderate': '#FFFF00',
  '#normalstatemoderate': '#FFFF00',
  '#highlightstatemoderate': '#FFFF00',

  '#unhealthysg': '#FF7E00',
  '#normalstateunhealthysg': '#FF7E00',
  '#highlightstateunhealthysg': '#FF7E00',

  '#unhealthy': '#FF0000',
  '#normalstateunhealthy': '#FF0000',
  '#highlightstateunhealthy': '#FF0000',

  '#veryunhealthy': '#8F3F97',
  '#normalstateveryunhealthy': '#8F3F97',
  '#highlightstateveryunhealthy': '#8F3F97',

  '#hazardous': '#7E0023',
  '#normalstatehazardous': '#7E0023',
  '#highlightstatehazardous': '#7E0023'
};

// Normalize and resolve a styleUrl to an AQI color
function getAqiColorFromStyleUrl(styleUrlRaw: string | null | undefined): string {
  const key = (styleUrlRaw || '').trim();
  if (!key) return '#D9D9D9';
  // ensure hash prefix and lowercase for lookup
  const normalized = (key.startsWith('#') ? key : `#${key}`).toLowerCase();
  return AQI_STYLE_COLORS[normalized] || '#D9D9D9';
}

export interface KMLLayer {
  addToMap: (map: M.Map) => Promise<void>
  removeFromMap: (map: M.Map) => void
  geoJsonData: any
  loading: Ref<boolean>
  error: Ref<string | null>
  kmlLayerVisible: WritableComputedRef<boolean>
  toggleKmlVisibility: (vis: boolean | undefined) => void
  setUrl: (newUrl: string) => Promise<void>
}

// Optional settings for labels
export interface UseKMLOptions {
  propertyToShow?: string | null;   // e.g., 'aqi'. If null/undefined, no labels are shown.
  labelMinZoom?: number;            // min zoom at which labels appear
  layerName?: string;               // custom id base for source/layers, e.g. 'aqi'
}

// Helper to sanitize a user-provided layer name into an id-safe suffix
function sanitizeIdBase(name: string): string {
  return name.trim().toLowerCase().replace(/[^a-z0-9-_]+/g, '-');
}

export function useKML(url: string, options: UseKMLOptions = {}): KMLLayer {
  const geoJsonData = ref<any>(null);
  const loading = ref(false);
  const error = ref<string | null>(null);

  // reactive URL
  const kmlUrl = ref<string>(url);
  // AbortController for in-flight fetch
  const currentFetchController = ref<AbortController | null>(null);

  const propertyToShow = options.propertyToShow ?? null;
  const labelMinZoom = options.labelMinZoom ?? 8;

  // Store runtime state in refs (avoid caching on the function)
  const mapRef = ref<M.Map | null>(null);
  const idBase = options.layerName ? sanitizeIdBase(options.layerName) : `kml-${Math.random().toString(36).slice(2)}`;
  const sourceId = `kml-source-${idBase}`;
  const layerId = `kml-layer-${idBase}`;
  const labelLayerIdConst = propertyToShow ? `kml-layer-${idBase}-labels` : null;

  const popupRef = ref<Popup | null>(null);
  const onEnterRef = ref<any>(null);
  const onMoveRef = ref<any>(null);
  const onLeaveRef = ref<any>(null);
  const onStyleDataRef = ref<any>(null);

  // Track the last known layer visibility across URL changes (persisted)
  const lastKnownVisible = ref<boolean>(true); // Generated by Copilot

  // kmlLayerVisible reflects actual map state; falls back to lastKnownVisible if layer missing
  const kmlLayerVisible = computed<boolean>({
    get() {
      const map = mapRef.value;
      if (!map || !map.getLayer(layerId)) {
        return lastKnownVisible.value;
      }
      const vis = (map.getLayoutProperty(layerId, 'visibility') as string) || 'visible';
      return vis === 'visible';
    },
    set(val: boolean) {
      lastKnownVisible.value = val;
      const map = mapRef.value;
      if (!map || !map.getLayer(layerId)) {
        console.error('KML visibility set attempted but layer is not available.');
        return;
      }
      const vis = val ? 'visible' : 'none';
      map.setLayoutProperty(layerId, 'visibility', vis);
      if (labelLayerIdConst && map.getLayer(labelLayerIdConst)) {
        map.setLayoutProperty(labelLayerIdConst, 'visibility', vis);
      }
    }
  });

  // Convert KML to GeoJSON
  const convertKmlToGeoJson = (kmlContent: string): any => {
    try {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlContent, 'application/xml');
      
      // Check for parsing errors
      const parseError = kmlDoc.querySelector('parsererror');
      if (parseError) {
        throw new Error('Invalid KML format');
      }
      
      // Convert using local togeojson library
      const geoJson = toGeoJSON.kml(kmlDoc, { styles: true });
      
      // Debug: Log the parsed GeoJSON structure
      console.log('=== KML PARSING DEBUG ===');
      console.log('URL:', kmlUrl.value);
      console.log('Total features:', geoJson.features.length);
      console.log('First few features with properties:', geoJson.features.slice(0, 3).map(f => ({
        geometry: f.geometry,
        properties: f.properties
      })));
      
      // Post-process to apply styleHash-based coloring
      const processedGeoJson = postProcessGeoJson(geoJson);
      
      return processedGeoJson;
    } catch (err) {
      console.error('KML conversion error:', err);
      throw new Error(`Failed to convert KML: ${err instanceof Error ? err.message : 'Unknown error'}`);
    }
  };

  // Post-process GeoJSON to apply styleUrl-based AQI coloring
  const postProcessGeoJson = (geoJson: any): any => {
    const processedFeatures = geoJson.features.map((feature: any) => {
      const processedFeature = { ...feature };
      const props = processedFeature.properties || {};
      const styleUrl = props.styleUrl ?? props.styleURL ?? null;
      const color = getAqiColorFromStyleUrl(styleUrl);
      processedFeature.properties = {
        ...props,
        'marker-color': color
      };
      return processedFeature;
    });

    return {
      ...geoJson,
      features: processedFeatures
    };
  };

  // Load KML from URL
  const loadKML = async (): Promise<void> => {
    loading.value = true;
    error.value = null;
    // Snapshot URL at request start
    const requestedUrl = kmlUrl.value;
    console.log('Starting KML load for URL:', requestedUrl);

    // Abort any in-flight request
    if (currentFetchController.value) {
      currentFetchController.value.abort();
    }
    const controller = new AbortController();
    currentFetchController.value = controller;

    try {
      console.log('Loading KML from:', requestedUrl);
      const response = await fetch(requestedUrl, { signal: controller.signal });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const kmlContent = await response.text();
      // If URL changed while fetching, ignore this response
      if (requestedUrl !== kmlUrl.value) {
        return;
      }
      const geoJson = convertKmlToGeoJson(kmlContent);
      // If URL changed while converting, ignore this result
      if (requestedUrl !== kmlUrl.value) {
        return;
      }
      geoJsonData.value = geoJson;
      console.log('KML loaded successfully:', geoJson.features.length, 'features');
    } catch (err: any) {
      // Swallow AbortError quietly
      if (err?.name === 'AbortError' || err instanceof DOMException && err.name === 'AbortError') {
        console.warn('KML fetch aborted:', requestedUrl);
        return;
      }
      console.error('Error loading KML:', err);
      error.value = err instanceof Error ? err.message : 'Unknown error';
      throw err;
    } finally {
      // Clear controller if it's still ours
      if (currentFetchController.value === controller) {
        currentFetchController.value = null;
      }
      loading.value = false;
    }
  };

  // Add GeoJSON to map
  const addToMap = async (map: M.Map): Promise<void> => {
    // Always store map first so subsequent retries have a reference
    mapRef.value = map;

    try {
      // Load KML if not already loaded
      if (!geoJsonData.value) {
        await loadKML();
      }
      if (!geoJsonData.value) {
        throw new Error('No GeoJSON data available');
      }

      console.log('=== ADDING TO MAP DEBUG ===');
      console.log('GeoJSON being added to map:', {
        type: geoJsonData.value.type,
        featureCount: geoJsonData.value.features.length,
        sampleFeature: geoJsonData.value.features[0]
      });

      // Remove existing layer and source if they exist
      if (map.getLayer(layerId)) {
        map.removeLayer(layerId);
      }
      if (labelLayerIdConst && map.getLayer(labelLayerIdConst)) {
        map.removeLayer(labelLayerIdConst);
      }
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId);
      }

      console.log(toRaw(geoJsonData.value));
      // Add new source and layer
      map.addSource(sourceId, {
        type: 'geojson',
        data: geoJsonData.value
      });

      // Add point layer colored by 'marker-color'
      map.addLayer({
        id: layerId,
        type: 'circle',
        source: sourceId,
        paint: {
          'circle-radius': [
            'interpolate', ['linear'], ['zoom'],
            0, 1,
            5, 8,
            20, 12
          ],
          'circle-color': [
            'case',
            ['has', 'marker-color'],
            ['get', 'marker-color'],
            '#808080'
          ],
          'circle-stroke-color': '#444444',
          'circle-stroke-width': 1,
          'circle-opacity': 0.8
        },
        filter: ['==', '$type', 'Point']
      });

      // Conditionally add text labels
      if (propertyToShow) {
        map.addLayer({
          id: labelLayerIdConst!,
          type: 'symbol',
          source: sourceId,
          minzoom: labelMinZoom,
          layout: {
            'text-field': ['coalesce', ['to-string', ['get', propertyToShow]], ''],
            'text-size': 10,
            'text-offset': [0, 0]
          },
          paint: {
            'text-color': '#1a1a1a',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          },
          filter: ['==', '$type', 'Point']
        });

        // Keep label visibility equal to main layer
        const syncLabelVisibility = () => {
          if (!map.getLayer(layerId) || !map.getLayer(labelLayerIdConst!)) return;
          const mainVis = (map.getLayoutProperty(layerId, 'visibility') as string) || 'visible';
          const labelVis = (map.getLayoutProperty(labelLayerIdConst!, 'visibility') as string) || 'visible';
          if (labelVis !== mainVis) {
            map.setLayoutProperty(labelLayerIdConst!, 'visibility', mainVis);
          }
        };
        syncLabelVisibility();
        map.on('styledata', syncLabelVisibility);
        onStyleDataRef.value = syncLabelVisibility;
      }

      // Add popup/handlers
      const popup = new Popup({ closeButton: false, closeOnClick: false, maxWidth: '200px' });
      const valueProp = propertyToShow || 'aqi';
      const onEnter = (e: any) => {
        map.getCanvas().style.cursor = 'pointer';
        const f = e.features && e.features[0];
        const val = f?.properties?.[valueProp];
        if (val !== undefined && val !== null && `${val}` !== '') {
          popup
            .setLngLat(e.lngLat)
            .setHTML(`<div style="font:12px sans-serif;color:#000">AQI: ${val}</div>`)
            .addTo(map);
        }
      };
      const onMove = (e: any) => {
        if ((popup as any)._map) {
          popup.setLngLat(e.lngLat);
          const f = e.features && e.features[0];
          const val = f?.properties?.[valueProp];
          if (val !== undefined && val !== null && `${val}` !== '') {
            popup.setHTML(`<div style="font:12px sans-serif;color:#000">AQI: ${val}</div>`);
          }
        }
      };
      const onLeave = () => {
        map.getCanvas().style.cursor = '';
        popup.remove();
      };
      map.on('click', layerId, onEnter);
      map.on('mousemove', layerId, onMove);
      map.on('mouseleave', layerId, onLeave);

      // Store state in refs (not on function)
      popupRef.value = popup;
      onEnterRef.value = onEnter;
      onMoveRef.value = onMove;
      onLeaveRef.value = onLeave;

      // Apply last known visibility after layers are added
      const vis = lastKnownVisible.value ? 'visible' : 'none'; // Generated by Copilot
      map.setLayoutProperty(layerId, 'visibility', vis);
      if (labelLayerIdConst && map.getLayer(labelLayerIdConst)) {
        map.setLayoutProperty(labelLayerIdConst, 'visibility', vis);
      }

      console.log('Successfully added KML layer to map');
    } catch (err) {
      console.error('Error adding KML to map:', err);
      error.value = err instanceof Error ? err.message : 'Unknown error';
      // Do not throw; keep mapRef so future setUrl can retry
      return;
    }
  };
  
  // Optional: debug logging
  watch(kmlLayerVisible, (newVis) => {
    console.log('KML layer visibility changed to:', newVis);
  });

  // Toggle visibility for main and label layers using the computed setter
  const toggleKmlVisibility = (val: boolean | undefined): void => {
    const next = val ?? !kmlLayerVisible.value;
    kmlLayerVisible.value = next;
  };

  // Change URL and refresh layer
  const setUrl = async (newUrl: string): Promise<void> => {
    const next = (newUrl || '').trim();
    if (!next || next === kmlUrl.value) return; // idempotent, avoid loops

    // Abort any in-flight fetch before switching
    if (currentFetchController.value) {
      try { currentFetchController.value.abort(); } catch { /* ignore */ }
      currentFetchController.value = null;
    }

    kmlUrl.value = next;

    const map = mapRef.value;
    // Clear cached data so addToMap will reload if needed
    geoJsonData.value = null;
    error.value = null;

    if (map) {
      try {
        removeFromMap(map as any);
      } catch {
        console.error('Error removing existing KML layer during URL change');
      }
      await addToMap(map as any);
    }
  };

  // Watch for URL changes to auto-reload (will be idempotent due to early return)
  watch(kmlUrl, (newUrl) => {
    console.log('KML URL changed, reloading:', kmlUrl.value);
    setUrl(newUrl).catch(err => {
      console.error('Error reloading KML after URL change:', err);
    });
  });

  // Remove from map
  const removeFromMap = (map: M.Map): void => {
    try {
      // Before removal, capture current visibility into lastKnownVisible
      try {
        if (map.getLayer(layerId)) {
          const vis = (map.getLayoutProperty(layerId, 'visibility') as string) || 'visible'; // Generated by Copilot
          lastKnownVisible.value = vis === 'visible';
        }
      } catch {
        /* ignore */
      }

      // Abort any in-flight fetch
      if (currentFetchController.value) {
        try { currentFetchController.value.abort(); } catch { /* ignore */ }
        currentFetchController.value = null;
      }

      const popup = popupRef.value;
      const onEnter = onEnterRef.value;
      const onMove = onMoveRef.value;
      const onLeave = onLeaveRef.value;
      const onStyleData = onStyleDataRef.value;

      // Remove hover handlers and popup
      if (onEnter) {
        map.off('click', layerId, onEnter);
      }
      if (onMove) map.off('mousemove', layerId, onMove);
      if (onLeave) map.off('mouseleave', layerId, onLeave);
      if (popup) popup.remove();

      // Remove watcher
      if (onStyleData) {
        map.off('styledata', onStyleData);
        onStyleDataRef.value = null;
      }

      // Remove layers and source
      if (labelLayerIdConst && map.getLayer(labelLayerIdConst)) {
        map.removeLayer(labelLayerIdConst);
      }
      if (map.getLayer(layerId)) {
        map.removeLayer(layerId);
      }
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId);
      }

      // Clear stored handlers/popup; keep mapRef so we can re-add later
      popupRef.value = null;
      onEnterRef.value = null;
      onMoveRef.value = null;
      onLeaveRef.value = null;

      console.log('KML layer removed from map');
    } catch (err) {
      console.error('Error removing KML from map:', err);
    }
  };

  return {
    addToMap,
    removeFromMap,
    geoJsonData,
    loading,
    error,
    kmlLayerVisible,
    toggleKmlVisibility,
    setUrl
  };
}